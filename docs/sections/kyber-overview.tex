% =========================================================
% kyber-overview.tex
% =========================================================
% An overview of the Kyber algorithm

\section*{Problem Description - Kyber}

Kyber is based on the ideas of Learning with Errors (LWE) encryption. LWE encryption is a form of encryption that represents secret information as a set of equations with some errors. In practice, this is often done by adding noise to the encoded secret information in order to conceal it. Kyber uses the ring of polynomials $\mathbb{Z}^n_q$, which represents $n$-degree polynomials with coefficients in $\,mathbb{Z}_q$, the set of integers modulo $q$. Here, $q$ is a prime number (by default $3329$) and $n$ is a variable value that is often a power of $2$ (by default $256$) \cite{crystals-kyber}. Additionally, kyber works on vectors of $R$ of size $k = 3$ by default.



\subsection*{Algorithm Overview}

\subsubsection*{Background}

Before delving further into the algorithm we define some simple notation. We define the space $R = \mathbb{Z}^n_q$ to represent our space of polynomials. We thus can say that $R^k$ represents a vector of $k$ polynomials, and $R^{k \times k}$ represents a matrix of $k^2$ polynomials.Next, we define $\beta_\eta$ for some positive integer $\eta$ as follows:

$$\text{Sample }\{(a_i, b_i)\}^\eta_{i=1} \sim (\{0, 1\}^2)^\eta\text{ and output }\sum_{i=1}^\eta a_i - b_i$$

If $v$ is some polynomial, we can write $v \sim \beta_\eta$ to say that $v$ is a polynomial with coefficients generated by $\beta_\eta$. We can also thus define a vector of polynomials $v \sim \beta_\eta^k \in R^k$ as a vector of $k$ polynomials with coefficients generated by $\beta_\eta$.

\subsubsection*{Key Generation}

Kyber begins with a public deterministic pseudorandom matrix $A \in R^{k \times k}$ of uniform polynomials. In layman terms, $A$ is a $k$ by $k$ matrix of polynomials with uniformly random coefficients (modulo $q$). Next is a pseudorandom vector of polynomials $s \sim \beta_\eta^k \in R^k$ that represents the secret key of the algorithm. The public key $t$ is generated by computing $t = A \cdot s + e$ \cite{crystals-kyber}, where $e \sim \beta_\eta^k \in R^k$ is a random error term that introduces noise into the key. The fact that it is computationally hard to recover $s$ from $t$ is the crucial result of the Learning with Errors problem \cite{lwe}.

\subsubsection*{Encryption}

Given a message $m$ encoded as a polynomial $m \in R^k$, Kyber encrypts $m$ by a random polynomial $r \in R^k$ and two random error terms $e_1 \sim \beta_\eta^k \in R^k$ and $e_2 \sim \beta_\eta \in R$. The encryption process is as follows:

\begin{align*}
  u & = A^T \cdot r + e_1     \\
  v & = t^T \cdot r + e_2 + m
\end{align*}

The encryption process is designed such that multiple encryptions of the same message will result in different ciphertexts (due to different random $r$), making it difficult to analyze correspondence between messages. The output of the encryption function is $(u, v)$.

\subsubsection*{Decryption}

Given the ciphertext $(u, v)$, the decryption process is as follows:

\begin{align*}
  v - s^Tu & = (t^Tr + e_2 + m) - s^T (A^Tr + e_1)                              \\
           & = ((As + e)^Tr + e_2 + m) - s^T (A^Tr + e_1)                       \\
           & = (\cancel{s^TA^Tr} + e^Tr + e_2 + m) - \cancel{s^T A^Tr} - s^Te_1 \\
           & = e^Tr + e_2 + m - s^Te_1-
\end{align*}

And as the error terms are specifically chosen to be small, the original message $m$ can be recovered from the decryption process.




% By default, kyber uses q = 3329 and n = 256, although these values are tunable parameters.
% To generate a keypair, we use a 3x3 public matrix of polynomial elements A given a random polynomial vector s as a private key.
% The public key t is generated by performing A * s + e, for some small error term e. Recovering s from t is computationally hard due to the error term as well as the math being performed over a finite ring with modular reduction.
% Then, we can encrypt a message m using a sequence of matrix multiplications and another random vector r to generate two encrypted vectors u = A^T * r + e1 and v = t^T * r + e2 + m.
% This has the added advantage of allowing multiple different encryptions of the same input message, making it difficult to analyze correspondence between messages.
% Decrypting using the secret key is also a series of vector operations, simply v - u^T * s, and as shown in the math to the bottom right all the terms cancel out, and as the error terms are specifically chosen to be small, this allows the original message to be recovered.
